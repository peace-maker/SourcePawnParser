%header {:
package spbeaver;
:};

%import "spbeaver.UnaryOperator.UnaryOp";
%import "spbeaver.BinaryOperator.BinaryOp";
%import "java.util.HashMap";

%terminals INTEGERLIT, FLOATLIT, CHARLIT, STRINGLIT, IDENTIFIER, LABEL;
%terminals LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET, SEMICOLON, COMMA;//, DOT;
%terminals ASSIGN, LT, GT, BANG, TILDE, QMARK, COLON, PLUS, MINUS, STAR, SLASH, AMPERSAND, BITOR, BITXOR, PERCENT;
%terminals ASSIGN_ADD, ASSIGN_SUB, ASSIGN_MUL, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITAND;
%terminals ASSIGN_BITOR, ASSIGN_BITXOR, ASSIGN_SHR, ASSIGN_SHRU, ASSIGN_SHL;
%terminals EQ, LE, GE, NE, LOGICOR, LOGICAND, SHL, SHRU, SHR, INC, DEC;
%terminals ELLIPSES;//, DOUBLEDOT, DOUBLECOLON;

//%terminals RESERVED;
%terminals BREAK, CASE, CONST, CONTINUE, DECL, DEFAULT, DO;
%terminals FALSE, FOR;
%terminals NEW, SIZEOF;
%terminals SWITCH, STATIC, TRUE, WHILE;
//%terminals BREAK, CASE, CELLSOF, CONST, CONTINUE, DECL, DEFAULT, DO;
//%terminals ELSE, ENUM, FALSE, FOR, FORWARD, FUNCENUM, FUNCTAG, ;
//%terminals GOTO, IF, NATIVE, NEW, OPERATOR, PUBLIC, RETURN, SIZEOF;
//%terminals STOCK, STRUCT, SWITCH, TAGOF, STATIC, TRUE, WHILE;

//%terminals CHAR, DELETE, FLOAT, INT, METHODMAP, NULL, NULLABLE;
//%terminals THIS, TYPEDEF, TYPESET, VIEWAS;

%left LPAREN, RPAREN;
%left STAR, SLASH, PERCENT;
%right PLUS, MINUS;
%left SHL, SHRU, SHR;
%left AMPERSAND;
%left BITXOR;
%left BITOR;
%left LT, LE, GT, GE;
%left EQ, NE;
%left LOGICAND;
%left LOGICOR;
%left QMARK, COLON;
%left ASSIGN, ASSIGN_ADD, ASSIGN_SUB, ASSIGN_MUL, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITAND, ASSIGN_BITOR, ASSIGN_BITXOR, ASSIGN_SHR, ASSIGN_SHRU, ASSIGN_SHL;

%left INC, DEC, MINUS, BANG, TILDE;
%left LABEL;
%left IDENTIFIER;

%typeof Statement = "Statement";
%typeof StatementList = "List<Statement>";
%typeof Stmt = "Statement";
%typeof LocalVarDecl = "Statement";
%typeof Declaration = "Declaration";
%typeof OldDeclVar = "Declaration";
%typeof OldArrayDim = "List";
%typeof Init = "Expression";

%typeof Block = "Statement";
%typeof While = "Statement";
%typeof DoWhile = "Statement";
%typeof CaseList = "List<SwitchCase>";
%typeof Switch = "Statement";
%typeof DefaultCase = "Statement";
%typeof For = "Statement";

%typeof Expression = "Expression";
%typeof Assignment = "Expression";
%typeof AssignmentOperator = "BinaryOp";

%typeof Ternary = "Expression";
%typeof Or = "Expression";
%typeof And = "Expression";

%typeof Equals = "Expression";
%typeof EqualsOperator = "BinaryOp";

%typeof Relational = "Expression";
%typeof RelationalOperator = "BinaryOp";

%typeof BitOr = "Expression";
%typeof BitXor = "Expression";
%typeof BitAnd = "Expression";

%typeof Shift = "Expression";
%typeof ShiftOperator = "BinaryOp";

%typeof Addition = "Expression";
%typeof AdditionOperator = "BinaryOp";

%typeof Multiplication = "Expression";
%typeof MultiplicationOperator = "BinaryOp";

%typeof Unary = "Expression";
%typeof SizeOf = "Expression";
%typeof EmptyDims = "Integer";
%typeof ArrayAccess = "Expression";
%typeof Primary = "Expression";
%typeof Postfix = "Expression";
%typeof Prefix = "Expression";
%typeof Primitive = "Expression";
%typeof Boolean = "SPBoolean";
%typeof CompoundLiteral = "ArrayLiteral";
%typeof StructInitializer = "List<StructElement>";
%typeof ExpressionList = "List<Expression>";
%typeof Identifier = "Identifier";
%typeof Label = "Label";

%typeof INTEGERLIT, FLOATLIT, CHARLIT, STRINGLIT, IDENTIFIER, LABEL = "String";

%typeof Goal = "SourcePawnFile";
%goal Goal;

Goal = StatementList.s {: return new SourcePawnFile(s); :}
;

Statement = Stmt.stmt;
// TODO: Save static or const qualifiers
Stmt = Block
	 | STATIC LocalVarDecl.var Term
	 | CONST LocalVarDecl.var Term
	 | NEW LocalVarDecl.var Term
	 | DECL LocalVarDecl.var Term
	 | While
	 | DoWhile Term
	 | Switch
	 | For
	 | BREAK Term {: return new Break(); :}
	 | CONTINUE Term {: return new Continue(); :}
	 | Expression.a Term {: return new ExpressionStatement(a); :} // TODO: Why no Expression
;

StatementList = Statement.s
			  {:
			  	List<Statement> l = new List<>();
			  	l.add(s);
			  	return new Symbol(l);
			  :}
			  | StatementList.l Statement.s
			  {:
			  	l.add(s);
			  	return _symbol_l;
			  :}
;

LocalVarDecl = Declaration.decl Init.init? {: return new VarDecl(decl, init!=null?new Opt<Expression>(init):new Opt<Expression>()); :}
;
Init = ASSIGN Expression.e // Initialization
;

Declaration = OldDeclVar;

OldDeclVar = CONST.c? Label.label? Identifier.name OldArrayDim.dims?
			{: return new Declaration(name, label==null?new Opt<Label>():new Opt<Label>(label), c.value != null, dims==null?new List():dims); :}
;

//OldDeclArg = CONST? AMPERSAND? Label? ELLIPSES // Variadic
//		   | CONST? AMPERSAND? Label? Identifier OldArrayDim?
//;

OldArrayDim = LBRACKET Expression.e? RBRACKET // size unspecified
			{: List l = new List();
			   	l.add(e);
			   	return l;
			:}
			| OldArrayDim.dims LBRACKET Expression.e? RBRACKET
			{:
			   	dims.add(e);
			   	return _symbol_dims;
			:}
;

While = WHILE LPAREN Expression.e RPAREN Statement.s {: return new While(e, s); :};
DoWhile = DO Block.s WHILE LPAREN Expression.e RPAREN {: return new DoWhile(e, s); :};

Switch = SWITCH LPAREN Expression.e RPAREN LBRACE CaseList.cases DefaultCase.def? RBRACE
	   {: return new Switch(e, cases, def==null?new Opt<Statement>():new Opt<Statement>(def)); :}
;
// FIXME: Handle LABEL matches for |Identifier:| cases
CaseList = CASE Label.label Statement.s
		 {:
		 	List<SwitchCase> l = new List<>();
		 	List<Expression> e = new List<>();
		 	e.add(new Identifier(label.getID()));
		 	l.add(new SwitchCase(e, s));
		 	return new Symbol(l);
		 :} 
		 | CASE ExpressionList.e COMMA Label.label Statement.s
		 {:
		 	List<SwitchCase> l = new List<>();
		 	e.add(new Identifier(label.getID()));
		 	l.add(new SwitchCase(e, s));
		 	return new Symbol(l);
		 :}
		 | CASE ExpressionList.e COLON Statement.s
		 {:
		 	List<SwitchCase> l = new List<>();
		 	l.add(new SwitchCase(e, s));
		 	return new Symbol(l);
		 :}
		 | CaseList.l CASE Label.label Statement.s
		 {:
		 	List<Expression> e = new List<>();
		 	e.add(new Identifier(label.getID()));
		 	l.add(new SwitchCase(e, s));
		 	return _symbol_l;
		 :}
		 | CaseList.l CASE ExpressionList.e COMMA Label.label Statement.s
		 {:
		 	e.add(new Identifier(label.getID()));
		 	l.add(new SwitchCase(e, s));
		 	return _symbol_l;
		 :}
		 | CaseList.l CASE ExpressionList.e COLON Statement.s
		 {:
		 	l.add(new SwitchCase(e, s));
		 	return _symbol_l;
		 :}
;
DefaultCase = DEFAULT COLON Statement.s
			| Label.l Statement.s
			{:
				// FIXME: catch actual errors.
				if(!l.getID().equals("default"))
					report.syntaxError(l); 
				return s;
			:}
;

For = FOR LPAREN Statement.init SEMICOLON Expression.cond SEMICOLON ExpressionList.step RPAREN Statement.body
	{: return new ForLoop(init==null?new Opt<Statement>():new Opt<Statement>(init), 
						  cond==null?new Opt<Expression>():new Opt<Expression>(cond), 
						  step, 
						  body); 
	:}
;

Block = LBRACE StatementList.l RBRACE {: return new Block(l); :};


// EXPRESSIONS
Expression = Assignment;
ExpressionList = Expression.e
				{: 
				   List<Expression> l = new List<>();
				   l.add(e);
				   return new Symbol(l);
				:}
			   | ExpressionList.l COMMA Expression.e
			   	{:
			   	  l.add(e);
			   	  return _symbol_l;
			   	:}
;

Assignment = Ternary
		   | Assignment.as AssignmentOperator.op Ternary.rhs
		   {:
		   		return new Assignment(op, as, rhs);
		   :}
;

AssignmentOperator = ASSIGN {: return new Symbol(BinaryOp.NONE); :}
				   | ASSIGN_ADD {: return new Symbol(BinaryOp.PLUS); :}
				   | ASSIGN_SUB {: return new Symbol(BinaryOp.MINUS); :}
				   | ASSIGN_MUL {: return new Symbol(BinaryOp.MUL); :}
				   | ASSIGN_DIV {: return new Symbol(BinaryOp.DIV); :}
				   | ASSIGN_MOD {: return new Symbol(BinaryOp.MOD); :}
				   | ASSIGN_BITAND {: return new Symbol(BinaryOp.BITAND); :}
				   | ASSIGN_BITOR {: return new Symbol(BinaryOp.BITOR); :}
				   | ASSIGN_BITXOR {: return new Symbol(BinaryOp.BITXOR); :}
				   | ASSIGN_SHR {: return new Symbol(BinaryOp.SHR); :}
				   | ASSIGN_SHRU {: return new Symbol(BinaryOp.SHRU); :}
				   | ASSIGN_SHL {: return new Symbol(BinaryOp.SHL); :}
;

Ternary = Or
		//| Or.cond QMARK LABEL.l Expression.right
		//{:
			// A ? B:C would normally get evaluated as NAME QMARK LABEL NAME, but we
    		// special case it here so that the LABEL becomes NAME and the colon gets
    		// stolen.
		//	return new TernaryExpression(cond, new Identifier(l.substring(0, l.length()-2)), right);
		//:}
		| Or.cond QMARK Expression.left COLON Expression.right
		{:
			return new TernaryExpression(cond, left, right);
		:}
;
Or = And
   | And.lhs LOGICOR And.rhs
   {:
   		return new BinaryExpression(BinaryOp.OR, lhs, rhs);
   :}
;
And = Equals
    | Equals.lhs LOGICAND Equals.rhs
    {:
    	return new BinaryExpression(BinaryOp.AND, lhs, rhs);
    :}
;
Equals = Relational
		 | Relational.lhs EqualsOperator.op Relational.rhs
		 {:
		 	return new BinaryExpression(op, lhs, rhs);
		 :}
;
EqualsOperator = EQ {: return new Symbol(BinaryOp.EQ); :}
			   | NE {: return new Symbol(BinaryOp.NE); :}
;

Relational = BitOr
		   | BitOr.lhs RelationalOperator.op BitOr.rhs
		   {:
		  		return new BinaryExpression(op, lhs, rhs);
		   :}
;
RelationalOperator = LT {: return new Symbol(BinaryOp.LT); :}
				   | LE {: return new Symbol(BinaryOp.LE); :}
				   | GT {: return new Symbol(BinaryOp.GT); :}
				   | GE {: return new Symbol(BinaryOp.GE); :}
;

BitOr = BitXor
	   | BitXor.lhs BITOR BitXor.rhs
	   {:
	   		return new BinaryExpression(BinaryOp.BITOR, lhs, rhs);
	   :}
;
BitXor = BitAnd
	   | BitAnd.lhs BITXOR BitAnd.rhs
	   {:
	   		return new BinaryExpression(BinaryOp.BITXOR, lhs, rhs);
	   :}
;
BitAnd = Shift
	   | Shift.lhs AMPERSAND Shift.rhs
	   {:
	   		return new BinaryExpression(BinaryOp.BITAND, lhs, rhs);
	   :}
;

Shift = Addition
	  | Addition.lhs ShiftOperator.op Addition.rhs
	  {:
	  	return new BinaryExpression(op, lhs, rhs);
	  :}
;
ShiftOperator = SHL {: return new Symbol(BinaryOp.SHL); :}
			  | SHR {: return new Symbol(BinaryOp.SHR); :}
			  | SHRU {: return new Symbol(BinaryOp.SHRU); :}
;
Addition = Multiplication
		 | Multiplication.lhs AdditionOperator.op Multiplication.rhs
		 {:
		 	return new BinaryExpression(op, lhs, rhs);
		 :}
;
AdditionOperator = PLUS {: return new Symbol(BinaryOp.PLUS); :}
				 | MINUS {: return new Symbol(BinaryOp.MINUS); :}
;

Multiplication = Unary
			   | Unary.lhs MultiplicationOperator.op Unary.rhs
			   {:
			   		return new BinaryExpression(op, lhs, rhs);
			   :}
;
MultiplicationOperator = SLASH {: return new Symbol(BinaryOp.DIV); :} 
					   | STAR  {: return new Symbol(BinaryOp.MUL); :} 
					   | PERCENT {: return new Symbol(BinaryOp.MOD); :}
;

SizeOf = LPAREN SizeOf.s RPAREN
	   | Identifier.i EmptyDims.d? {: return new SizeOf(i, d==null?0:d); :}
;
EmptyDims = LBRACKET RBRACKET
			{: return new Symbol(1); :}
		  | EmptyDims.e LBRACKET RBRACKET
		    {: return new Symbol(e + 1); :}
;
Unary = INC Unary.u {: return new IncDec(UnaryOp.INC, u, false); :} // Increment
	  | DEC Unary.u {: return new IncDec(UnaryOp.DEC, u, false); :} // Decrement
	  | MINUS Unary.u {: return new UnaryExpr(UnaryOp.NEG, u); :} // Negate
	  | BANG Unary.u {: return new UnaryExpr(UnaryOp.INV, u); :}    // Invert
	  | TILDE Unary.u {: return new UnaryExpr(UnaryOp.COMPL, u); :}// Complement
	  | SIZEOF SizeOf.s        // sizeof expression
	  //| Label.l Unary.u {: return new UnsafeCast(l, u); :}// unsafe cast
	  // no view_as support yet.
	  | Postfix
;

Postfix = Primary.p INC {: return new IncDec(UnaryOp.INC, p, true); :}
	  	| Primary.p DEC {: return new IncDec(UnaryOp.DEC, p, true); :}
	  	| Primary
;
Primary = Prefix.name LPAREN ExpressionList.l? RPAREN {: return new Call(name, l); :} // function call
		| ArrayAccess // (multi) array element
		| Prefix
;

ArrayAccess = Prefix.base LBRACKET Expression.e RBRACKET
			{:
				return new Index(base, e);
			:}
			| ArrayAccess.l LBRACKET Expression.e RBRACKET
			{:
				return new Index(l, e);
			:}
;

Prefix = LPAREN Expression.e RPAREN {: return new Parenthesis(e); :}
	   | Identifier
	   | Primitive
;
Primitive = FLOATLIT.f {: return new SPFloat(f); :}
		  | INTEGERLIT.i {: return new SPInteger(i); :}
		  | Boolean
		  | STRINGLIT.s {: return new SPString(s); :}
		  | CHARLIT.s {: return new SPString(s); :}
		  | CompoundLiteral
;
Boolean = TRUE {: return new True(); :}
		| FALSE {: return new False(); :}
;

CompoundLiteral = LBRACE StructInitializer.s COMMA? RBRACE {: return new StructInitializer(s); :}
				| LBRACE ELLIPSES.e? RBRACE {: return new ArrayLiteral(new List(), e.value != null); :}
				| LBRACE ExpressionList.l COMMA ELLIPSES.e RBRACE {: return new ArrayLiteral(l, true); :}
				| LBRACE ExpressionList.l RBRACE {: return new ArrayLiteral(l, false); :}
;
StructInitializer = Identifier.id ASSIGN Expression.e
				  {:
				  	List<StructElement> l = new List<>();
				  	l.add(new StructElement(id, e));
				  	return new Symbol(l);
				  :}
				  | StructInitializer.s COMMA Identifier.id ASSIGN Expression.e
				  {:
				  	s.add(new StructElement(id, e));
				  	return _symbol_s;
				  :}
;

Identifier = IDENTIFIER.id {: return new Identifier(id); :};
Label = LABEL.l {: return new Label(l.substring(0, l.length()-1)); :};

Term = SEMICOLON;


//ReservedKeyWord = RESERVED.r {: System.err.println("'" + r + "' is a newly reserved keyword that may be used in the future; use a different name as an identifier"); return r; :};