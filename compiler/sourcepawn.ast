SourcePawnFile ::= Statements:Statement*;


abstract Statement;
EmptyStatement:Statement;
PreprocessorLine:Statement ::= <RawLine:String>;

Break:Statement;
Continue:Statement;
ExpressionStatement:Statement ::= Expr:Expression;

Declaration ::= [Name:Identifier] [Label:Label] Dims:Expression* <Flags:int>;
VarDecl:Statement ::= Var:Declaration [Init:Expression] [Next:VarDecl];

Method:Statement ::= Name:Identifier [Label:Label] <Flags:int> Args:VarDecl* [Body:Statement];

FuncEnum:Statement ::= Name:Identifier Methods:FuncEnumElement*;
FuncEnumElement:Statement ::= [Label:Label] Args:VarDecl*;

While:Statement ::= Condition:Expression Body:Statement;
DoWhile:While;
Switch:Statement ::= Expr:Expression Cases:SwitchCase* [Default:Statement];
SwitchCase:Statement ::= Expr:Expression* Body:Statement;

ForLoop:Statement ::= [Init:Statement] [Condition:Expression] Steps:Statement* Body:Statement;

Return:Statement ::= [Expr:Expression];
If:Statement ::= Condition:Expression TrueBranch:Statement [FalseBranch:Statement];

Block:Statement ::= Statements:Statement*;

EnumStatement:Statement ::= [Name:Identifier] Constants:EnumConstant*;
EnumConstant:Statement ::= Decl:Declaration [Init:Expression];

StructStatement:Statement ::= Name:Identifier Fields:Declaration*;

abstract Expression;
EmptyExpression:Expression;

Assignment:Expression ::= <Operator:BinaryOp> LHS:Expression RHS:Expression;
TernaryExpression:Expression ::= Condition:Expression Left:Expression Right:Expression;
BinaryExpression:Expression ::= <Operator:BinaryOp> LHS:Expression RHS:Expression;

abstract Unary:Expression;
UnaryExpr:Expression ::= <Operator:UnaryOp> Expr:Expression;
IncDec:UnaryExpr ::= <Postfix:boolean>;
SizeOf:Unary ::= Name:Identifier <Level:int>;
UnsafeCast:Unary ::= Label Expr:Expression;

abstract Primary:Expression;
// FIXME: MethodName doesn't have to be a Prefix. Only Identifier allowed?
// FIXME: Parser::primary() allows for 5(); or a[1][2](); function calls?!
Call:Primary ::= MethodName:Expression Arguments:Expression*;
Index:Primary ::= Base:Expression Index:Expression;


abstract Prefix:Expression;
Identifier:Prefix ::= <ID:String>;
Label:Identifier;
Parenthesis:Prefix ::= Expr:Expression;

// Primitives
abstract SPBoolean:Primitive;
abstract Primitive:Expression;
True:SPBoolean;
False:SPBoolean;
SPFloat:Primitive ::= <Float:String>;
SPInteger:Primitive ::= <Integer:String>;
SPString:Primitive ::= <String:String>;
SPCharacter:Primitive ::= <Char:String>;

ArrayLiteral:Primitive ::= Expressions:Expression* <RepeatLastElement:boolean>;
StructInitializer:Primitive ::= Elements:StructElement*;
StructElement ::= Identifier Value:Expression;